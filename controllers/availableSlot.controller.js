const availableSlotService = require('../services/availableSlot.service');

/**
 * ‚≠ê NEW: Generate danh s√°ch khung gi·ªù tr·ªëng cho m·ªôt ng√†y
 * GET /api/available-slots/generate?serviceId=xxx&date=2025-10-25
 * D√πng ƒë·ªÉ FE hi·ªÉn th·ªã c√°c slot kh·∫£ d·ª•ng sau khi ch·ªçn d·ªãch v·ª• + ng√†y
 */
const generateSlotsByDate = async (req, res) => {
  try {
    const { serviceId, date, breakAfterMinutes, appointmentFor, customerFullName, customerEmail } = req.query;
    const userId = req.user?.userId || null; // L·∫•y userId n·∫øu user ƒë√£ login

    // Validation
    if (!serviceId || !date) {
      return res.status(400).json({
        success: false,
        message: 'Vui l√≤ng cung c·∫•p ƒë·∫ßy ƒë·ªß serviceId v√† date'
      });
    }

    // Validate date format
    const searchDate = new Date(date);
    if (isNaN(searchDate.getTime())) {
      return res.status(400).json({
        success: false,
        message: 'ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng format: YYYY-MM-DD'
      });
    }

    console.log('üîç [generateSlotsByDate] User ID:', userId ? userId : 'Guest');
    console.log('üîç [generateSlotsByDate] appointmentFor:', appointmentFor || 'not specified');
    if (appointmentFor === 'other') {
      console.log('üîç [generateSlotsByDate] Customer:', customerFullName, '<' + customerEmail + '>');
    }

    // ‚≠ê Ch·ªâ pass userId n·∫øu appointmentFor === 'self' ho·∫∑c kh√¥ng specify (default l√† self)
    // N·∫øu appointmentFor === 'other', kh√¥ng pass userId ƒë·ªÉ kh√¥ng exclude
    const patientUserIdForExclusion = (appointmentFor === 'self' || !appointmentFor) && userId ? userId : null;

    const result = await availableSlotService.generateAvailableSlotsByDate({
      serviceId,
      date: searchDate,
      breakAfterMinutes: breakAfterMinutes ? parseInt(breakAfterMinutes) : 10,
      patientUserId: patientUserIdForExclusion, // ‚≠ê Ch·ªâ exclude khi appointmentFor === 'self'
      // ‚≠ê Pass customer info n·∫øu appointmentFor === 'other'
      ...(appointmentFor === 'other' && {
        customerFullName: customerFullName ? decodeURIComponent(customerFullName) : null,
        customerEmail: customerEmail ? decodeURIComponent(customerEmail) : null,
      }),
    });

    res.status(200).json({
      success: true,
      data: result
    });

  } catch (error) {
    console.error('L·ªói generate slots by date:', error);

    if (error.message.includes('Kh√¥ng t√¨m th·∫•y') ||
        error.message.includes('kh√¥ng ho·∫°t ƒë·ªông') ||
        error.message.includes('Vui l√≤ng cung c·∫•p')) {
      return res.status(400).json({
        success: false,
        message: error.message
      });
    }

    res.status(500).json({
      success: false,
      message: 'L·ªói server khi generate danh s√°ch khung gi·ªù',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * L·∫•y danh s√°ch khung gi·ªù available ƒë·ªông
 * GET /api/available-slots?doctorUserId=xxx&serviceId=yyy&date=2025-10-21
 */
const getAvailableSlots = async (req, res) => {
  try {
    const { doctorUserId, serviceId, date, breakAfterMinutes } = req.query;

    // Validation
    if (!doctorUserId || !serviceId || !date) {
      return res.status(400).json({
        success: false,
        message: 'Vui l√≤ng cung c·∫•p ƒë·∫ßy ƒë·ªß doctorUserId, serviceId v√† date'
      });
    }

    // Validate date format
    const searchDate = new Date(date);
    if (isNaN(searchDate.getTime())) {
      return res.status(400).json({
        success: false,
        message: 'ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng format: YYYY-MM-DD'
      });
    }

    // Get current user ID from auth middleware
    const patientUserId = req.user?.userId;

    const result = await availableSlotService.getAvailableSlots({
      doctorUserId,
      serviceId,
      date: searchDate,
      patientUserId,
      breakAfterMinutes: breakAfterMinutes ? parseInt(breakAfterMinutes) : 10
    });

    res.status(200).json({
      success: true,
      data: result
    });

  } catch (error) {
    console.error('L·ªói l·∫•y available slots:', error);

    if (error.message.includes('Kh√¥ng t√¨m th·∫•y') ||
        error.message.includes('kh√¥ng ho·∫°t ƒë·ªông') ||
        error.message.includes('Vui l√≤ng cung c·∫•p')) {
      return res.status(400).json({
        success: false,
        message: error.message
      });
    }

    res.status(500).json({
      success: false,
      message: 'L·ªói server khi l·∫•y danh s√°ch khung gi·ªù available',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * L·∫•y danh s√°ch t·∫•t c·∫£ b√°c sƒ© c√≥ khung gi·ªù r·∫£nh v√†o ng√†y c·ª• th·ªÉ
 * GET /api/available-slots/doctors?serviceId=xxx&date=2025-10-21
 */
const getAvailableDoctors = async (req, res) => {
  try {
    const { serviceId, date, breakAfterMinutes } = req.query;

    // Validation
    if (!serviceId || !date) {
      return res.status(400).json({
        success: false,
        message: 'Vui l√≤ng cung c·∫•p ƒë·∫ßy ƒë·ªß serviceId v√† date'
      });
    }

    // Validate date format
    const searchDate = new Date(date);
    if (isNaN(searchDate.getTime())) {
      return res.status(400).json({
        success: false,
        message: 'ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng format: YYYY-MM-DD'
      });
    }

    const result = await availableSlotService.getAvailableDoctors({
      serviceId,
      date: searchDate,
      breakAfterMinutes: breakAfterMinutes ? parseInt(breakAfterMinutes) : 10
    });

    res.status(200).json({
      success: true,
      data: result
    });

  } catch (error) {
    console.error('L·ªói l·∫•y danh s√°ch b√°c sƒ© c√≥ khung gi·ªù r·∫£nh:', error);

    if (error.message.includes('Kh√¥ng t√¨m th·∫•y') ||
        error.message.includes('kh√¥ng ho·∫°t ƒë·ªông') ||
        error.message.includes('Vui l√≤ng cung c·∫•p')) {
      return res.status(400).json({
        success: false,
        message: error.message
      });
    }

    res.status(500).json({
      success: false,
      message: 'L·ªói server khi l·∫•y danh s√°ch b√°c sƒ©',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * L·∫•y danh s√°ch b√°c sƒ© c√≥ khung gi·ªù r·∫£nh t·∫°i m·ªôt khung gi·ªù c·ª• th·ªÉ
 * GET /api/available-slots/doctors/time-slot?serviceId=xxx&date=2025-10-21&startTime=2025-10-21T09:00:00Z&endTime=2025-10-21T09:30:00Z
 */
const getAvailableDoctorsForTimeSlot = async (req, res) => {
  try {
    const { serviceId, date, startTime, endTime } = req.query;

    // Validation
    if (!serviceId || !date || !startTime || !endTime) {
      return res.status(400).json({
        success: false,
        message: 'Vui l√≤ng cung c·∫•p ƒë·∫ßy ƒë·ªß serviceId, date, startTime v√† endTime'
      });
    }

    // Validate date format
    const searchDate = new Date(date);
    if (isNaN(searchDate.getTime())) {
      return res.status(400).json({
        success: false,
        message: 'ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng format: YYYY-MM-DD'
      });
    }

    const slotStart = new Date(startTime);
    const slotEnd = new Date(endTime);

    if (isNaN(slotStart.getTime()) || isNaN(slotEnd.getTime())) {
      return res.status(400).json({
        success: false,
        message: 'ƒê·ªãnh d·∫°ng startTime ho·∫∑c endTime kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng format ISO 8601'
      });
    }

    if (slotStart >= slotEnd) {
      return res.status(400).json({
        success: false,
        message: 'startTime ph·∫£i nh·ªè h∆°n endTime'
      });
    }

    // Get current user ID from auth middleware
    const patientUserId = req.user?.userId;

    const result = await availableSlotService.getAvailableDoctorsForTimeSlot({
      serviceId,
      date: searchDate,
      startTime: slotStart,
      endTime: slotEnd,
      patientUserId
    });

    res.status(200).json({
      success: true,
      data: result
    });

  } catch (error) {
    console.error('L·ªói l·∫•y danh s√°ch b√°c sƒ© cho khung gi·ªù c·ª• th·ªÉ:', error);
    console.error('Error message:', error.message);

    if (error.message.includes('Kh√¥ng t√¨m th·∫•y') ||
        error.message.includes('kh√¥ng ho·∫°t ƒë·ªông') ||
        error.message.includes('Vui l√≤ng cung c·∫•p') ||
        error.message.includes('kh√¥ng kh·ªõp')) {
      return res.status(400).json({
        success: false,
        message: error.message
      });
    }

    res.status(500).json({
      success: false,
      message: 'L·ªói server khi l·∫•y danh s√°ch b√°c sƒ©',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

module.exports = {
  generateSlotsByDate,
  getAvailableSlots,
  getAvailableDoctors,
  getAvailableDoctorsForTimeSlot
};

